
import React, { useState } from 'react';
import { ArrowLeft, Copy, Download, Save } from 'lucide-react';
import { useAuth } from '@/hooks/useAuth';
import { useForm } from 'react-hook-form';
import { v4 as uuidv4 } from 'uuid';
import { toast } from 'sonner';
import Editor from '@monaco-editor/react';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs';
import { useWorkspaceTasks, DocumentPayload } from '@/hooks/useWorkspaceTasks';

interface DocumentGeneratorProps {
  selectedWorkspaceId?: string;
  onBack?: () => void;
}

const DocumentGenerator: React.FC<DocumentGeneratorProps> = ({
  selectedWorkspaceId,
  onBack
}) => {
  const { user } = useAuth();
  const { saveDocumentTask } = useWorkspaceTasks(selectedWorkspaceId || '');
  
  const [documentType, setDocumentType] = useState('markdown');
  const [sourceContent, setSourceContent] = useState(
`# API Documentation Sample

## Overview
This API allows you to manage users and their data.

## Endpoints

### GET /users
Returns a list of all users.

#### Parameters
- **page** (optional): Page number for pagination
- **limit** (optional): Number of items per page

#### Responses
- 200 OK: Successfully retrieved users
- 401 Unauthorized: Authentication required
- 500 Internal Server Error: Server error

### POST /users
Creates a new user.

#### Request Body
\`\`\`json
{
  "name": "John Doe",
  "email": "john@example.com",
  "role": "user"
}
\`\`\`

#### Responses
- 201 Created: User successfully created
- 400 Bad Request: Invalid input
- 401 Unauthorized: Authentication required
- 500 Internal Server Error: Server error
`
  );
  
  const [generatedDocument, setGeneratedDocument] = useState('');
  const [generating, setGenerating] = useState(false);
  
  const { register, handleSubmit, formState: { errors } } = useForm({
    defaultValues: {
      taskName: '',
      description: ''
    }
  });
  
  const handleGenerateDocument = async () => {
    if (!sourceContent.trim()) {
      toast.error('Please provide source content');
      return;
    }
    
    setGenerating(true);
    
    try {
      // For demo/mock purposes, we'll format the document
      // In a real app, this would call an API to process the document
      setTimeout(() => {
        try {
          // Generate formatted document
          const processedDocument = generateMockDocument(documentType, sourceContent);
          setGeneratedDocument(processedDocument);
          toast.success('Document generated successfully!');
        } catch (error) {
          console.error('Error generating document:', error);
          toast.error('Failed to generate document');
        } finally {
          setGenerating(false);
        }
      }, 1500);
    } catch (error) {
      console.error('Error generating document:', error);
      toast.error('Failed to generate document');
      setGenerating(false);
    }
  };
  
  const generateMockDocument = (type: string, content: string) => {
    // This is a very simplified mock document generation
    // In a real app, you would use a proper document processing service
    
    if (type === 'markdown') {
      // For markdown, we'll just clean it up and add some metadata
      return `---
title: Generated Documentation
date: ${new Date().toISOString().split('T')[0]}
author: Document Generator
---

${content}

---
*This document was automatically generated by the Document Generator*
`;
    } else if (type === 'html') {
      // For HTML, we'll convert markdown-like content to basic HTML
      const htmlContent = content
        .replace(/^# (.*?)$/gm, '<h1>$1</h1>')
        .replace(/^## (.*?)$/gm, '<h2>$1</h2>')
        .replace(/^### (.*?)$/gm, '<h3>$1</h3>')
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        .replace(/```(.*?)```/gs, '<pre><code>$1</code></pre>')
        .replace(/^- (.*?)$/gm, '<li>$1</li>')
        .split('\n\n').map(paragraph => {
          if (!paragraph.startsWith('<h') && !paragraph.startsWith('<pre') && !paragraph.startsWith('<li')) {
            return `<p>${paragraph.replace(/\n/g, ' ')}</p>`;
          }
          return paragraph;
        }).join('\n');
      
      return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Generated Documentation</title>
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }
    h1, h2, h3 { color: #333; }
    pre { background-color: #f5f5f5; padding: 10px; border-radius: 4px; overflow-x: auto; }
    code { font-family: monospace; }
  </style>
</head>
<body>
  ${htmlContent}
  <hr>
  <footer>
    <em>This document was automatically generated by the Document Generator</em>
  </footer>
</body>
</html>`;
    } else {
      // Default text formatting
      return content + '\n\n--- Generated by Document Generator ---';
    }
  };
  
  const handleCopyToClipboard = () => {
    if (generatedDocument) {
      navigator.clipboard.writeText(generatedDocument);
      toast.success('Document copied to clipboard!');
    }
  };
  
  const handleDownload = () => {
    if (generatedDocument) {
      const extension = documentType === 'markdown' ? 'md' : documentType === 'html' ? 'html' : 'txt';
      const mimeType = documentType === 'html' ? 'text/html' : 'text/plain';
      
      const blob = new Blob([generatedDocument], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `generated-document.${extension}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      toast.success('Document downloaded!');
    }
  };
  
  const handleSaveTask = handleSubmit(async (data) => {
    if (!user || !selectedWorkspaceId) {
      toast.error('You must be logged in to save a task');
      return;
    }
    
    if (!generatedDocument) {
      toast.error('Please generate a document first');
      return;
    }
    
    try {
      const uniqueId = uuidv4().substring(0, 8);
      
      const payload: DocumentPayload = {
        task_id: uniqueId,
        task_name: data.taskName || `${documentType.charAt(0).toUpperCase() + documentType.slice(1)} Document`,
        user_id: user.id,
        workspace_id: selectedWorkspaceId,
        description: data.description || '',
        document_type: documentType,
        source_content: sourceContent,
        generated_document: generatedDocument,
        category: 'document'
      };
      
      const result = await saveDocumentTask(payload);
      
      if (result) {
        toast.success('Document task saved successfully!');
        if (onBack) {
          onBack();
        }
      }
    } catch (error) {
      console.error('Error saving document task:', error);
      toast.error('Failed to save document task');
    }
  });
  
  return (
    <div className="container mx-auto px-4 py-8 max-w-7xl">
      <div className="flex items-center mb-6">
        <Button 
          variant="ghost" 
          size="sm" 
          className="mr-2" 
          onClick={onBack}
        >
          <ArrowLeft className="h-4 w-4 mr-1" />
          Back
        </Button>
        <h1 className="text-2xl font-bold">Document Generator</h1>
      </div>
      
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <div className="space-y-6">
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6">
            <h2 className="text-xl font-semibold mb-4">Source Content</h2>
            
            <div className="mb-4">
              <Label htmlFor="documentType">Document Type</Label>
              <Select
                value={documentType}
                onValueChange={setDocumentType}
              >
                <SelectTrigger id="documentType">
                  <SelectValue placeholder="Select document type" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="markdown">Markdown</SelectItem>
                  <SelectItem value="html">HTML</SelectItem>
                  <SelectItem value="text">Plain Text</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="h-72 border rounded-md overflow-hidden">
              <Editor
                language={documentType === 'markdown' ? 'markdown' : documentType === 'html' ? 'html' : 'plaintext'}
                value={sourceContent}
                onChange={(value) => setSourceContent(value || '')}
                theme="vs-dark"
                options={{
                  minimap: { enabled: false },
                  scrollBeyondLastLine: false,
                  fontSize: 14
                }}
              />
            </div>
            
            <Button 
              className="w-full mt-4" 
              onClick={handleGenerateDocument}
              disabled={generating}
            >
              {generating ? 'Generating...' : 'Generate Document'}
            </Button>
          </div>
          
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6">
            <form onSubmit={handleSaveTask} className="space-y-4">
              <div>
                <Label htmlFor="taskName">Task Name</Label>
                <Input
                  id="taskName"
                  placeholder="Enter a name for this document"
                  {...register('taskName', { required: 'Task name is required' })}
                />
                {errors.taskName && (
                  <p className="text-red-500 text-sm mt-1">{errors.taskName.message}</p>
                )}
              </div>
              
              <div>
                <Label htmlFor="description">Description (Optional)</Label>
                <Textarea
                  id="description"
                  placeholder="Enter a description for this document"
                  {...register('description')}
                  className="h-24"
                />
              </div>
              
              <Button 
                type="submit" 
                className="w-full"
                disabled={!generatedDocument}
              >
                <Save className="h-4 w-4 mr-2" />
                Save Document
              </Button>
            </form>
          </div>
        </div>
        
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-semibold">Generated Document</h2>
            <div className="flex space-x-2">
              <Button 
                variant="outline" 
                size="sm"
                onClick={handleCopyToClipboard}
                disabled={!generatedDocument}
              >
                <Copy className="h-4 w-4 mr-1" />
                Copy
              </Button>
              <Button 
                variant="outline" 
                size="sm"
                onClick={handleDownload}
                disabled={!generatedDocument}
              >
                <Download className="h-4 w-4 mr-1" />
                Download
              </Button>
            </div>
          </div>
          
          <div className="border rounded-md overflow-hidden h-[600px]">
            {documentType === 'html' && generatedDocument ? (
              <div className="h-full overflow-auto bg-white p-4">
                <iframe
                  srcDoc={generatedDocument}
                  title="Generated HTML Document"
                  className="w-full h-full border-0"
                  sandbox="allow-same-origin"
                />
              </div>
            ) : (
              <Editor
                language={documentType === 'markdown' ? 'markdown' : 'plaintext'}
                value={generatedDocument}
                theme="vs-dark"
                options={{
                  readOnly: true,
                  minimap: { enabled: false },
                  scrollBeyondLastLine: false,
                  fontSize: 14
                }}
              />
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default DocumentGenerator;
